import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ProvisionWorkPaperHierarchy {

    public static void main(String[] args) {
        List<ProvisionWorkPaperData> provisionWorkPaperDataList = List.of(
                new ProvisionWorkPaperData("GAAP to STAT", "Permanent", "PVG01", "Misc", 100),
                new ProvisionWorkPaperData("GAAP to STAT", "Permanent", "PVG01", "Misc 2", 100),
                new ProvisionWorkPaperData("GAAP to STAT", "Temporary", "PVG02", "Misc 3", 100),
                new ProvisionWorkPaperData("STAT to TAX", "Permanent", "PVG01", "Misc", 100),
                new ProvisionWorkPaperData("STAT to TAX", "Permanent", "PVG01", "Misc 2", 100),
                new ProvisionWorkPaperData("STAT to TAX", "Temporary", "PVG02", "Misc 3", 100),
                new ProvisionWorkPaperData("PTBI", "Temporary", "PVG02", "Misc 3", 100),
                new ProvisionWorkPaperData("NOL", "Temporary", "PVG02", "Misc 3", 100)


        );

        List<DifferenceCategory> hierarchy = buildInitialHierarchy(provisionWorkPaperDataList);

        // Print the hierarchy
        printHierarchy(hierarchy);
    }

    private static List<DifferenceCategory> buildInitialHierarchy(List<ProvisionWorkPaperData> data) {
        // Initialize an empty list to hold the hierarchy as it gets built
        List<DifferenceCategory> hierarchy = new ArrayList<>();

        // Build the hierarchy category by category
        data.stream()
                .collect(Collectors.groupingBy(ProvisionWorkPaperData::differenceCategory))
                .entrySet()
                .forEach(categoryEntry -> {
                    String category = categoryEntry.getKey();
                    List<ProvisionWorkPaperData> categoryData = categoryEntry.getValue();

                    CategoryCalculationStrategy strategy;
                    switch (category) {
                        case "GAAP to STAT":
                        case "STAT to TAX":
                            strategy = new DefaultHierarchyStrategy();
                            break;
                        case "PTBI":
                            strategy = new PtbiStrategy();
                            break;
                        case "NOL":  // Use the new strategy here
                            strategy = new SameAsGaapToStatStrategy();
                            break;
                        default:
                            return; // Skip NOL for now
                    }

                    // Calculate the category and add it to the hierarchy list
                    DifferenceCategory calculatedCategory = strategy.calculateCategory(category, categoryData, hierarchy);
                    hierarchy.add(calculatedCategory);
                });

        return hierarchy;
    }

    private static void printHierarchy(List<DifferenceCategory> hierarchy) {
        for (DifferenceCategory category : hierarchy) {
            System.out.println("- " + category.differenceCategory() + " (" + category.totalAmount() + ")");
            for (DifferenceTiming timing : category.differenceTimings()) {
                System.out.println("  -- " + timing.differenceTiming() + " (" + timing.totalAmount() + ")");
                for (OtpCode otpCode : timing.otpCodes()) {
                    System.out.println("    --- " + otpCode.otpCodeName() + " (" + otpCode.totalAmount() + ")");
                    for (DifferenceNameAmount diff : otpCode.differences()) {
                        System.out.println("      ---- " + diff.differenceName() + ": " + diff.ytdAmount());
                    }
                }
            }
        }
    }

    // Record definitions
    public record DifferenceNameAmount(String differenceName, int ytdAmount) {}

    public record OtpCode(String otpCodeName, int totalAmount, List<DifferenceNameAmount> differences) {}

    public record DifferenceTiming(String differenceTiming, int totalAmount, List<OtpCode> otpCodes) {}

    public record DifferenceCategory(String differenceCategory, int totalAmount, List<DifferenceTiming> differenceTimings) {}

    public record ProvisionWorkPaperData(
            String differenceCategory,
            String differenceTiming,
            String otpCodeName,
            String differenceName,
            int ytdAmount
    ) {}

    // Strategy Interface
    public interface CategoryCalculationStrategy {
        DifferenceCategory calculateCategory(String categoryName, List<ProvisionWorkPaperData> data, List<DifferenceCategory> currentHierarchy);
    }

    // Default Hierarchy Strategy for GAAP to STAT and STAT to TAX
    public static class DefaultHierarchyStrategy implements CategoryCalculationStrategy {
        @Override
        public DifferenceCategory calculateCategory(String categoryName, List<ProvisionWorkPaperData> data, List<DifferenceCategory> currentHierarchy) {
            // Step 1: Compute the current category's total
            int currentCategoryTotal = data.stream().mapToInt(ProvisionWorkPaperData::ytdAmount).sum();

            // Step 2: Sum it with the previous category total (if any)
            int previousCategoryTotal = currentHierarchy.isEmpty() ? 0 : currentHierarchy.get(currentHierarchy.size() - 1).totalAmount();

            int categoryTotal = previousCategoryTotal + currentCategoryTotal;

            // Step 3: Build the hierarchy (timings, otpCodes, differences)
            List<DifferenceTiming> timings = data.stream()
                    .collect(Collectors.groupingBy(ProvisionWorkPaperData::differenceTiming))
                    .entrySet()
                    .stream()
                    .map(timingEntry -> {
                        String timing = timingEntry.getKey();
                        List<ProvisionWorkPaperData> timingData = timingEntry.getValue();
                        int timingTotal = timingData.stream().mapToInt(ProvisionWorkPaperData::ytdAmount).sum();

                        List<OtpCode> otpCodes = timingData.stream()
                                .collect(Collectors.groupingBy(ProvisionWorkPaperData::otpCodeName))
                                .entrySet()
                                .stream()
                                .map(otpEntry -> {
                                    String otpCode = otpEntry.getKey();
                                    List<ProvisionWorkPaperData> otpData = otpEntry.getValue();
                                    int otpTotal = otpData.stream().mapToInt(ProvisionWorkPaperData::ytdAmount).sum();

                                    List<DifferenceNameAmount> differences = otpData.stream()
                                            .map(pwd -> new DifferenceNameAmount(pwd.differenceName(), pwd.ytdAmount()))
                                            .toList();

                                    return new OtpCode(otpCode, otpTotal, differences);
                                })
                                .toList();

                        return new DifferenceTiming(timing, timingTotal, otpCodes);
                    })
                    .toList();

            // Step 4: Return the updated DifferenceCategory with the combined total
            return new DifferenceCategory(categoryName, categoryTotal, timings);
        }
    }

    // PTBI Strategy (Gets value from a reference table)
    public static class PtbiStrategy implements CategoryCalculationStrategy {
        @Override
        public DifferenceCategory calculateCategory(String categoryName, List<ProvisionWorkPaperData> data, List<DifferenceCategory> currentHierarchy) {
            int ptbiValue = ReferenceData.REFERENCE_TABLE.getOrDefault("PTBI", 0);
            return new DifferenceCategory(categoryName, ptbiValue, List.of());
        }
    }

    // Strategy that assigns the total of the GAAP to STAT category to this new category
    public static class SameAsGaapToStatStrategy implements CategoryCalculationStrategy {
        @Override
        public DifferenceCategory calculateCategory(String categoryName, List<ProvisionWorkPaperData> data, List<DifferenceCategory> currentHierarchy) {
            // Find the previously computed GAAP to STAT category
            DifferenceCategory gaapToStatCategory = currentHierarchy.stream()
                    .filter(c -> c.differenceCategory().equals("GAAP to STAT"))
                    .findFirst()
                    .orElseThrow(() -> new IllegalStateException("GAAP to STAT category must be computed first"));

            // Use the same total as GAAP to STAT
            int categoryTotal = gaapToStatCategory.totalAmount();

            // Optionally, you can replicate the structure (timings, otpCodes, differences), or keep it simple
            return new DifferenceCategory(categoryName, categoryTotal, List.of()); // Empty timings for now
        }
    }


    // Reference Data for PTBI
    public static class ReferenceData {
        public static final Map<String, Integer> REFERENCE_TABLE = Map.of(
                "PTBI", 5000  // Example PTBI value
        );
    }
}
